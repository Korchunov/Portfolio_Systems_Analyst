1. В каких городах больше одного аэропорта?

select a.city, count(a.airport_code) as airport_code
from airports a
group by 1
having count(a.airport_code) > 1

* Работаем в домене airports a и делаем из него выборку
* Выводим атрибуты "город" и "код аэропорта" (применяем к "код аэропорта" аргегатную функцию и считаем количество аэропортов в каждом городе)
* Проводим группировку по городу
* В условии к групперовке указываем, что количество аэропортов в городе должно быть больше 1

-----------------------------------------------------------------

2.В каких аэропортах есть рейсы, выполняемые самолетом с максимальной дальностью перелета? (подзапрос)

select a.airport_code, a.airport_name, a2.aircraft_code, a2.model, a2.range
from airports a 
join flights f on a.airport_code = f.departure_airport 
join aircrafts a2 on f.aircraft_code = a2.aircraft_code 
where a2."range" = (select max("range") from aircrafts a3)
group by 1, 3

* Работаем в домене airports a и делаем из него выборку
* Присоединяем домен "Рейсы" и связываем с доменом "Аэропорты" по уникальным значениям
* Присоединяем домен "Самолёты" и связываем с доменом "Рейсы" по уникальным значениям
* Выводим код аэропорта, наименование аэропорта, код самолёта, модель самолёта и дальность полёта самолёта
* В условии пишем, что дальность полёта самолёта = подзапрос, в котором через агрегатную функцию находим максимальную дальность полёта 
* Группируем по по коду аэропорта и коду самолёта

-----------------------------------------------------------------

3.Вывести 10 рейсов с максимальным временем задержки вылета (LIMIT)

select f.flight_id, f.flight_no, concat(f.departure_airport, '-', f.arrival_airport) as departure_arrival,
f.actual_departure - f.scheduled_departure as delay
from flights f
where f.actual_departure is not null 
order by 4 desc
limit 10

* Работаем в домене airports a и делаем из него выборку
* Выводим идентификатор рейса, номер рейса, через конкатенацию объединяем аэропорт вылета и аэропорт прилёта, производим вычитание: 
от фактического времени вылета отнимаем ожидаемое время вылета
* В условии пишем, что фактическое время вылета не может равняться нулю 
* Сортируем по разнице в вылете от большего к меньшему
* Выводим только первые 10 значений

-----------------------------------------------------------------

4. Были ли брони, по которым не были получены посадочные талоны? (Верный тип JOIN)

--explain analyze (rows=127899)
select b.book_ref as номер_бр, bp.boarding_no as номер_пос_тал, t.ticket_no as номер_билета, f.flight_id as идент_рейса
from bookings b 
left join tickets t on b.book_ref = t.book_ref 
left join boarding_passes bp on t.ticket_no = bp.ticket_no 
left join flights f on bp.flight_id = f.flight_id 
where bp.boarding_no is null

* Работаем в домене bookings b и делаем из него выборку
* Присоединяем домен "Билеты" и связываем с доменом "Бронирование" по уникальным значениям. 
Присоединяем через left join, чтобы в результат вошли все значения из "bookings b" и соответствующие им значения из "tickets t"
* Присоединяем домен "Посадочные талоны" и связываем с доменом "Билеты" по уникальным значениям. 
Присоединяем через left join, чтобы в результат вошли все значения из "tickets t" и соответствующие им значения из "boarding_passes bp"
* Присоединяем домен "Рейсы" и связываем с доменом "Посадочные талоны" по уникальным значениям. 
Присоединяем через left join, чтобы в результат вошли все значения из "boarding_passes" и соответствующие им значения из "flights f"
* Выводим номер бронирования, номер посадочного талона, номер билета и идентификатор рейса
* В условии пишем, что результат с номером посадочного талона должен быть равен нулю

-----------------------------------------------------------------

5.Найдите количество свободных мест для каждого рейса, их % отношение к общему количеству мест в самолете.
Добавьте столбец с накопительным итогом - суммарное накопление количества вывезенных пассажиров из каждого
аэропорта на каждый день. Т.е. в этом столбце должна отражаться накопительная сумма - сколько человек уже 
вылетело из данного аэропорта на этом или более ранних рейсах в течении дня. 
(- Оконная функция
- Подзапросы или/и cte )

with cte1 as (
	select s.aircraft_code, count(s.seat_no) as flight_seat 
	from seats s 
	group by 1),
cte2 as (
	select 
	f.flight_id, f.departure_airport, f.scheduled_departure, f.actual_departure, cte1.aircraft_code,
	cte1.flight_seat, count(tf.ticket_no) as count_passenger,
	cte1.flight_seat - count(tf.ticket_no) as count_free_seat,
	round(((cte1.flight_seat::numeric - count(tf.ticket_no::numeric)) * 100) / cte1.flight_seat::numeric) as count_free_seat_percent
	from flights f 
	join cte1 on f.aircraft_code = cte1.aircraft_code
	join ticket_flights tf on tf.flight_id = f.flight_id 
	where f.actual_departure is not null
	group by 1, 5, 6)
select 
	cte2.flight_id, 
	cte2.departure_airport, 
	cte2.scheduled_departure, 
	cte2.actual_departure, 
	cte1.flight_seat, 
	cte2.count_passenger,
	cte2.count_free_seat, 
	cte2.count_free_seat_percent,
sum(cte2.count_passenger) over (partition by (cte2.departure_airport, cte2.actual_departure::date) order by cte2.actual_departure)
from cte1
join cte2 on cte1.aircraft_code = cte2.aircraft_code
order by 1

* Создаём временный результат запроса cte1:
  - Работаем в домене seats s и делаем из него выборку
  - Выводим код самолёта, через агрегатную функцию выводим количество посадочных мест в самолёте 
  - Группируем по коду самолёта
* Создаём временный результат запроса cte2: 
  - Работаем в домене flights f и делаем из него выборку
  - Присоединяем домен с временным результатом запроса "cte1" и связываем с доменом "Рейсы" по уникальным значениям
  - Присоединяем домен "Посадочные талоны" и связываем с временным результатом запроса "cte1" по уникальным значениям
  - Выводим идентификатор рейса, аэропорт вылета, ожидаемое время вылета, фактическое время вылета, номер самолёта, количество мест в самолёте,
    количество билетов через агрегатную функцию, количество свободных мест путём вычитания количества купленных билетов от общего количества мест в самолёте,
    процентное соотношение свободных мест в самолёте от общего количества через вычисление:
    количество мест в самолёте переводим в тип данных с плавующей точкой (numeric) --> вычитаем количество купленных билетов (также переводим в тип данных numeric)
    -->умножаем на 100 --> делим на общее количество мест в самолёте
  - В условии пишем, что фактическое время вылета не должно равняться нулю, с целью исключить результаты со значением "null"

* Работаем с временным результатом запроса cte1 и делаем из него выборку
* Присоединяем домен с временным результатом запроса "cte2" и связываем с временным результатом запроса "cte1" по уникальным значениям
* Выводим идентификатор рейса, аэропорт вылета, планируемое время вылета, фактическое время вылета, общее количество мест в самолёте,
  количество пассажиров в рейсе, количество свободных мест в рейсе, количество свободных мест в рейсе в процентах от общего количества мест в самолёте,
  через оконную функцию выводим сумму купленных билетов под алиасом 'количество пассажиров', прописываем партиции для аэропорта вылета и фактического времени вылета,
  переведённого в тип данных date, сортируем по фактическому времени вылета 
* Сортируем по идентификатору рейса 
    

-----------------------------------------------------------------

6. Найти процентное соотношение перелётов по типам самолётов от общего количества (подзапрос или окно, оператор ROUND)


select a.aircraft_code, a.model, round((count(f.flight_id)::numeric * 100) / (select count(flight_id)::numeric from flights f2)) as relationship
from flights f 
join aircrafts a on f.aircraft_code = a.aircraft_code 
group by 1

* Работаем в домене flights f и делаем из него выборку
* Присоединяем домен "Самолёты" и связываем с доменом "Рейсы" по уникальным значениям
* Выводим код самолёта, модель самолёта, процентное соотношение перелётов по типам самолётов от общего количества через вычисление:
через агрегатную функцию находим количество рейсов по идентификатору рейса и переводим в тип данных с плавующей точкой (numeric) --> умножаем на 100 -->
делим на подзапрос, в котором через агрегатную функцию находим количество рейсов по идентификатору рейса и переводим в тип данных с плавующей точкой (numeric) -->
в результате получаем значение с плавующей точкой и через оператор округления округляем данное значение до целого числа согласно математическому округлению
* Группируем по коду самолёта

-----------------------------------------------------------------

7. Были ли города, в которые можно добраться бизнес - классом дешевле, чем эконом - классом в рамках перелёта? (СТЕ)

with cte as (
	select f.flight_id,
	case when tf.fare_conditions  = 'Business' then min(tf.amount) end min_business,
	case when tf.fare_conditions  = 'Economy' then max(tf.amount) end max_economy
	from ticket_flights tf 
	join flights f on tf.flight_id = f.flight_id 
	group by 1, tf.fare_conditions
	)
select f2.flight_id, concat(f2.departure_airport, '-', f2.arrival_airport) as departure_arrival, a2.city, 
min(cte.min_business) as min_business, max(cte.max_economy) as max_economy
from flights f2 
join cte on f2.flight_id = cte.flight_id
join airports a2 on a2.airport_code = f2.arrival_airport 
group by 1, 3
having min(cte.min_business) < max(cte.max_economy)

* Создаём временный результат запроса:
  - Работаем в домене ticket_flights tf и делаем из него выборку
  - Присоединяем домен "Рейсы" и связываем с доменом "Перелёты" по уникальным значениям
  - С помощью оператора CASE задаём условие: 
    ~ если класс обслуживания равен "Бизнесс", то через агрегатную функцию находим минимальную стоимость за билет в бизнесс-классе
    ~ если класс обслуживания равен "Эконом", то через агрегатную функцию находим максимальную стоимость за билет в эконом-классе
  - Выводим идентификатор рейса
  - Группируем по идентификатору рейса и по классу обслуживания
* Работаем в домене flights f2  и делаем из него выборку
* Присоединяем домен с временным результатом запроса "cte" и связываем с доменом "Рейсы" по уникальным значениям
* Присоединяем домен "Аэропорты" и связываем с временным результатом запроса "cte" по уникальным значениям
* Выводим идентификатор рейса, через конкатенацию объединяем аэропорт вылета и аэропорт прилёта, город с аэропортом, 
через агрегатную функцию находим минимальную стоимость за билет в бизнесс-классе и максимальную стоимость за билет в эконом-классе 
(повторная агрегация проводится для того, чтобы не осуществлять по ним группировку)
* Группируем по идентификатору рейса и городу с аэропортом
* В условии к группировке пишем, что минимальная стоимость за билет в бизнесс-классе должна быть меньше, чем максимальная стоимость за билет в эконом-классе 
-----------------------------------------------------------------

8. Между какими городами нет прямых рейсов? 
(Декартово произведение в предложении FROM, самостоятельно созданные представления, оператор EXCEPT)

create view view1 as (
	select a.city as city_departure, a2.city as city_arrival
	from flights f 
	join airports a on f.departure_airport = a.airport_code
	join airports a2 on f.arrival_airport = a2.airport_code)
	
select distinct a.city departure_city, a2.city arrival_city 
from airports a cross join airports a2 
where a.city != a2.city
except 
select *
from view1

* Создаём представление view1:
  - Работаем в домене flights f  и делаем из него выборку
  - Присоединяем домен "Аэропорты" и связываем с доменом "Рейсы" по уникальным значениям
  - Повторно присоединяем домен "Аэропорты" и связываем с доменом "Рейсы" по уникальным значениям
  - Выводим город вылета и город прилёта
* Работаем в домене airports a  и делаем из него выборку
* Присоединяем домен "airports a2" по принципу Декартова множества
* Выводим униальные значения города вылета и города прилёта
* В условии пишем, что город вылета не должен равняться городу прилёта
* Через оператор EXCEPT присоединяем результат запроса со всеми значениями из созданного ранее представления 

-----------------------------------------------------------------

9. Вычислите расстояние между аэропортами, связанными прямыми рейсами, сравните с допустимой максимальной дальностью перелётов в самолётах, обслуживающих
эти рейсы (Оператор RADIANS или использование sind/cosd, CASE)

- Кратчайшее расстояние между двумя точками А и В на земной поверхности:
d = arccos {sin(latitude_a)·sin(latitude_b) + cos(latitude_a)·cos(latitude_b)·cos(longitude_a - longitude_b)}, 
где latitude_a и latitude_b — широты, 
longitude_a, longitude_b — долготы данных пунктов, 
d — расстояние между пунктами измеряется в радианах длиной дуги большого круга земного шара.

-Расстояние между пунктами, измеряемое в километрах, определяется по формуле:
L = d·R, где R = 6371 км — средний радиус земного шара.


select 
concat (a.airport_name, ' - ', a3.airport_name) as airport_name,
concat(a.city, ' - ', a3.city) as departure_arrival_city,
a2.aircraft_code, a2."range",
round(acos(sind(a.latitude) * sind(a3.latitude) + cosd(a.latitude) * cosd(a3.latitude) * cosd(a.longitude - a3.longitude)) * 6371) as distance_between_airport,
case 
	when round(acos(sind(a.latitude) * sind(a3.latitude) + cosd(a.latitude) * cosd(a3.latitude) * cosd(a.longitude - a3.longitude)) * 6371) < a2."range"
	then '+'
	else '-'
end "flight possible?"
from flights f 
join airports a on a.airport_code = f.departure_airport 
join airports a3 on a3.airport_code = f.arrival_airport 
join aircrafts a2 on f.aircraft_code = a2.aircraft_code 

* Работаем в домене flights f  и делаем из него выборку
* Присоединяем домен "Аэропорты" и связываем с доменом "Рейсы" по уникальным значениям
* Повторно присоединяем домен "Аэропорты" и связываем с доменом "Рейсы" по уникальным значениям
* Присоединяем домен "Самолёты" и связываем с доменом "Рейсы" по уникальным значениям
* Выводим через конкатенацию аэропорт вылета и аэропорт прилёта, также через конкатенацию выводим город вылета и город прилёта, код самолёта, дальность полёта самолёта,
находим кратчайшее расстояние между двумя точками А и В на земной поверхности по формуле, с использованием операторов sind/cosd/acos
--> умножаем на 6371 и находим расстояние между пунктами, измеряемое в километрах --> полученное значение округляем до целого числа с помощью оператора ROUND
В операторе CASE прописываем:
 ~ Если кратчайшее расстояние между двумя точками А и В на земной поверхности меньше дальности полёта самолёта, то выводим '+' --> перелёт возможен
 ~ Если кратчайшее расстояние между двумя точками А и В на земной поверхности больше дальности полёта самолёта, то выводим '-' --> перелёт невозможен
